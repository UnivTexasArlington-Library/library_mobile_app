"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _usePrevious = _interopRequireDefault(require("./use-previous"));

var _InvisibleFiller = _interopRequireDefault(require("./InvisibleFiller"));

var _Dot = _interopRequireDefault(require("./Dot"));

var _styles = _interopRequireDefault(require("./styles"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable react-native/no-inline-styles */
const calculateDotSize = dot => dot.size + 2 * dot.margin;

const calculateDecreasingDotSize = dot => {
  return calculateDotSize(dot.config) * (dot.quantity * 2);
};

const calculateIndicatorDotSize = (maxIndicators, activeIndicatorConfig, inactiveIndicatorConfig) => {
  return calculateDotSize(activeIndicatorConfig) + calculateDotSize(inactiveIndicatorConfig) * (maxIndicators - 1);
};

const calculateOffsetSize = (decreasingDot, offset) => {
  const minimumSize = calculateDotSize(decreasingDot[decreasingDot.length - 1].config);
  const result = decreasingDot.reduce((acc, dot) => {
    if (acc.offset === 0) return acc;

    if (acc.offset - dot.quantity <= 0) {
      return {
        offset: 0,
        totalSize: acc.totalSize + calculateDotSize(dot.config) * acc.offset
      };
    }

    return {
      offset: acc.offset - dot.quantity,
      totalSize: acc.totalSize + calculateDotSize(dot.config) * dot.quantity
    };
  }, {
    offset,
    totalSize: 0
  });
  return result.totalSize + result.offset * minimumSize;
};

const CarouselDots = ({
  length,
  currentIndex,
  maxIndicators,
  activeIndicatorConfig,
  inactiveIndicatorConfig,
  decreasingDots,
  verticalOrientation = false,
  interpolateOpacityAndColor = true
}) => {
  const refScrollView = (0, _react.useRef)(null);
  const [curIndex, setCurIndex] = (0, _react.useState)(currentIndex);
  const positiveMomentum = (0, _react.useRef)(false);
  const prevIndex = (0, _usePrevious.default)(curIndex, curIndex);
  const [carouselState, setCarouselState] = (0, _react.useState)({
    currentIndex,
    state: 1
  });
  const list = [...Array(length).keys()];
  const scrollTo = (0, _react.useCallback)(index => {
    if (!refScrollView.current) return;
    const moveTo = positiveMomentum.current ? calculateOffsetSize(decreasingDots, index - maxIndicators + 1) : calculateOffsetSize(decreasingDots, index);
    refScrollView.current.scrollTo({
      animated: true,
      x: moveTo
    });
  }, [decreasingDots, maxIndicators]);
  (0, _react.useEffect)(() => {
    setCurIndex(currentIndex);
  }, [currentIndex]);
  (0, _react.useEffect)(() => {
    positiveMomentum.current = curIndex - prevIndex > 0;
    let internalState = carouselState.state;
    internalState += curIndex - prevIndex;
    const finalState = internalState;
    if (internalState > maxIndicators) internalState = maxIndicators;
    if (internalState < 1) internalState = 1;

    if (internalState) {
      setCarouselState({
        currentIndex: curIndex,
        state: internalState
      });
    }

    if (length > maxIndicators && (finalState > maxIndicators || finalState < 1)) scrollTo(curIndex); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [curIndex, length, maxIndicators, scrollTo]);
  const containerSize = decreasingDots.reduce((acc, current) => calculateDecreasingDotSize(current) + acc, 0) + calculateIndicatorDotSize(maxIndicators, activeIndicatorConfig, inactiveIndicatorConfig);

  if (length <= maxIndicators) {
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      style: _styles.default.container
    }, list.map(i => {
      return /*#__PURE__*/_react.default.createElement(_Dot.default, {
        key: i,
        index: i,
        maxIndicators: maxIndicators,
        activeIndicatorConfig: activeIndicatorConfig,
        inactiveIndicatorConfig: inactiveIndicatorConfig,
        verticalOrientation: verticalOrientation,
        decreasingDots: decreasingDots,
        carouselState: carouselState,
        interpolateOpacityAndColor: interpolateOpacityAndColor
      });
    }));
  }

  const invisibleFillerSize = decreasingDots.reduce((acc, current) => calculateDecreasingDotSize(current) + acc, 0) / 2;
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [verticalOrientation ? {
      flex: 1,
      height: containerSize
    } : {
      flex: 1,
      flexDirection: 'row',
      width: containerSize
    }]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.ScrollView, {
    ref: refScrollView,
    contentContainerStyle: _styles.default.scrollContainer,
    bounces: false,
    horizontal: !verticalOrientation,
    scrollEnabled: false,
    showsVerticalScrollIndicator: false,
    showsHorizontalScrollIndicator: false
  }, /*#__PURE__*/_react.default.createElement(_InvisibleFiller.default, {
    size: invisibleFillerSize,
    verticalOrientation: verticalOrientation
  }), list.map(i => {
    return /*#__PURE__*/_react.default.createElement(_Dot.default, {
      key: i,
      index: i,
      maxIndicators: maxIndicators,
      activeIndicatorConfig: activeIndicatorConfig,
      inactiveIndicatorConfig: inactiveIndicatorConfig,
      decreasingDots: decreasingDots,
      verticalOrientation: verticalOrientation,
      carouselState: carouselState,
      interpolateOpacityAndColor: interpolateOpacityAndColor
    });
  }), /*#__PURE__*/_react.default.createElement(_InvisibleFiller.default, {
    size: invisibleFillerSize,
    verticalOrientation: verticalOrientation
  })));
};

var _default = CarouselDots;
exports.default = _default;
//# sourceMappingURL=index.js.map
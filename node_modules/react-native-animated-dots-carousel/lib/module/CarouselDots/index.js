/* eslint-disable react-native/no-inline-styles */
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { View, ScrollView } from 'react-native';
import usePrevious from './use-previous';
import InvisibleFiller from './InvisibleFiller';
import Dot from './Dot';
import styles from './styles';

const calculateDotSize = dot => dot.size + 2 * dot.margin;

const calculateDecreasingDotSize = dot => {
  return calculateDotSize(dot.config) * (dot.quantity * 2);
};

const calculateIndicatorDotSize = (maxIndicators, activeIndicatorConfig, inactiveIndicatorConfig) => {
  return calculateDotSize(activeIndicatorConfig) + calculateDotSize(inactiveIndicatorConfig) * (maxIndicators - 1);
};

const calculateOffsetSize = (decreasingDot, offset) => {
  const minimumSize = calculateDotSize(decreasingDot[decreasingDot.length - 1].config);
  const result = decreasingDot.reduce((acc, dot) => {
    if (acc.offset === 0) return acc;

    if (acc.offset - dot.quantity <= 0) {
      return {
        offset: 0,
        totalSize: acc.totalSize + calculateDotSize(dot.config) * acc.offset
      };
    }

    return {
      offset: acc.offset - dot.quantity,
      totalSize: acc.totalSize + calculateDotSize(dot.config) * dot.quantity
    };
  }, {
    offset,
    totalSize: 0
  });
  return result.totalSize + result.offset * minimumSize;
};

const CarouselDots = ({
  length,
  currentIndex,
  maxIndicators,
  activeIndicatorConfig,
  inactiveIndicatorConfig,
  decreasingDots,
  verticalOrientation = false,
  interpolateOpacityAndColor = true
}) => {
  const refScrollView = useRef(null);
  const [curIndex, setCurIndex] = useState(currentIndex);
  const positiveMomentum = useRef(false);
  const prevIndex = usePrevious(curIndex, curIndex);
  const [carouselState, setCarouselState] = useState({
    currentIndex,
    state: 1
  });
  const list = [...Array(length).keys()];
  const scrollTo = useCallback(index => {
    if (!refScrollView.current) return;
    const moveTo = positiveMomentum.current ? calculateOffsetSize(decreasingDots, index - maxIndicators + 1) : calculateOffsetSize(decreasingDots, index);
    refScrollView.current.scrollTo({
      animated: true,
      x: moveTo
    });
  }, [decreasingDots, maxIndicators]);
  useEffect(() => {
    setCurIndex(currentIndex);
  }, [currentIndex]);
  useEffect(() => {
    positiveMomentum.current = curIndex - prevIndex > 0;
    let internalState = carouselState.state;
    internalState += curIndex - prevIndex;
    const finalState = internalState;
    if (internalState > maxIndicators) internalState = maxIndicators;
    if (internalState < 1) internalState = 1;

    if (internalState) {
      setCarouselState({
        currentIndex: curIndex,
        state: internalState
      });
    }

    if (length > maxIndicators && (finalState > maxIndicators || finalState < 1)) scrollTo(curIndex); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [curIndex, length, maxIndicators, scrollTo]);
  const containerSize = decreasingDots.reduce((acc, current) => calculateDecreasingDotSize(current) + acc, 0) + calculateIndicatorDotSize(maxIndicators, activeIndicatorConfig, inactiveIndicatorConfig);

  if (length <= maxIndicators) {
    return /*#__PURE__*/React.createElement(View, {
      style: styles.container
    }, list.map(i => {
      return /*#__PURE__*/React.createElement(Dot, {
        key: i,
        index: i,
        maxIndicators: maxIndicators,
        activeIndicatorConfig: activeIndicatorConfig,
        inactiveIndicatorConfig: inactiveIndicatorConfig,
        verticalOrientation: verticalOrientation,
        decreasingDots: decreasingDots,
        carouselState: carouselState,
        interpolateOpacityAndColor: interpolateOpacityAndColor
      });
    }));
  }

  const invisibleFillerSize = decreasingDots.reduce((acc, current) => calculateDecreasingDotSize(current) + acc, 0) / 2;
  return /*#__PURE__*/React.createElement(View, {
    style: [verticalOrientation ? {
      flex: 1,
      height: containerSize
    } : {
      flex: 1,
      flexDirection: 'row',
      width: containerSize
    }]
  }, /*#__PURE__*/React.createElement(ScrollView, {
    ref: refScrollView,
    contentContainerStyle: styles.scrollContainer,
    bounces: false,
    horizontal: !verticalOrientation,
    scrollEnabled: false,
    showsVerticalScrollIndicator: false,
    showsHorizontalScrollIndicator: false
  }, /*#__PURE__*/React.createElement(InvisibleFiller, {
    size: invisibleFillerSize,
    verticalOrientation: verticalOrientation
  }), list.map(i => {
    return /*#__PURE__*/React.createElement(Dot, {
      key: i,
      index: i,
      maxIndicators: maxIndicators,
      activeIndicatorConfig: activeIndicatorConfig,
      inactiveIndicatorConfig: inactiveIndicatorConfig,
      decreasingDots: decreasingDots,
      verticalOrientation: verticalOrientation,
      carouselState: carouselState,
      interpolateOpacityAndColor: interpolateOpacityAndColor
    });
  }), /*#__PURE__*/React.createElement(InvisibleFiller, {
    size: invisibleFillerSize,
    verticalOrientation: verticalOrientation
  })));
};

export default CarouselDots;
//# sourceMappingURL=index.js.map